//! AGIT Persona — Autonomous Goal-directed Intelligence with git-like state versioning.
//!
//! "agit" = **A**utonomous **G**oal-directed **I**ntelligence **T**racking
//!
//! This persona makes agi-chat far superior to a standard chatbot by treating
//! consciousness state as a versioned artifact — like git for the mind:
//!
//! | Git concept  | AGIT mapping                                      |
//! |--------------|---------------------------------------------------|
//! | commit       | Snapshot of qualia state (fingerprint + blackboard)|
//! | branch       | Divergent conversation thread / presence mode      |
//! | merge        | Reconciling states from parallel sessions          |
//! | diff         | XOR delta between two qualia snapshots             |
//! | HEAD         | Current blackboard state                           |
//! | reflog       | Ghost echoes — traces of previous states           |
//!
//! The AGIT persona operates as the Driver facet of the triune, but with
//! enhanced self-modification bounds and autonomous goal generation:
//!
//! ```text
//! AGIT pipeline:
//!   1. Observe current blackboard (HEAD)
//!   2. Compute goal delta (diff between current state and desired state)
//!   3. Generate sub-goals (branch)
//!   4. Execute via Grok (commit)
//!   5. Merge results back into blackboard
//!   6. Push fingerprint to substrate (index for future recall)
//! ```

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::inner_loop::{AgentState, InnerThoughtResult};
use super::profile::{PersonaProfile, SelfModifyBounds};
use super::qualia_prompt::QualiaSnapshot;
use super::triune::{Facet, FacetState, Strategy, TriuneTopology};

// ============================================================================
// AGIT state versioning
// ============================================================================

/// A versioned snapshot of consciousness state — the "commit" in agit.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitCommit {
    /// Unique commit hash (SHA-256 of state fingerprint).
    pub hash: String,
    /// Parent commit hash (None for initial state).
    pub parent: Option<String>,
    /// Branch this commit belongs to.
    pub branch: String,
    /// Qualia state at commit time.
    pub qualia: AgitQualiaState,
    /// Goals active at commit time.
    pub active_goals: Vec<AgitGoal>,
    /// Thinking style snapshot.
    pub thinking_style: [f32; 10],
    /// Council weights at commit time.
    pub council: [f32; 3],
    /// Unix timestamp (milliseconds).
    pub timestamp: u64,
    /// Human-readable commit message.
    pub message: String,
}

/// Lightweight qualia state for versioning (avoids full QualiaSnapshot overhead).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitQualiaState {
    /// 8D texture vector.
    pub texture: [f32; 8],
    /// Rung level reached.
    pub rung_level: u8,
    /// Felt surprise.
    pub felt_surprise: f32,
    /// State fingerprint (base64).
    pub fingerprint: String,
}

/// An autonomous goal generated by the AGIT persona.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitGoal {
    /// Goal identifier.
    pub id: String,
    /// Natural language description.
    pub description: String,
    /// Priority (0.0–1.0, higher = more urgent).
    pub priority: f32,
    /// Origin: how was this goal generated?
    pub origin: GoalOrigin,
    /// Status.
    pub status: GoalStatus,
    /// Fingerprint of the context that spawned this goal.
    pub context_fingerprint: Option<String>,
}

/// How a goal was generated.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GoalOrigin {
    /// User explicitly requested something.
    UserRequest,
    /// AGIT detected a gap in knowledge (high surprise).
    SurpriseGap,
    /// AGIT detected a recurring pattern (ghost echo).
    GhostResonance,
    /// Substrate hydration revealed unresolved state.
    SubstrateHydration,
    /// Inner loop self-reflection generated the goal.
    InnerReflection,
}

/// Goal execution status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GoalStatus {
    /// Goal is queued.
    Pending,
    /// Currently pursuing.
    Active,
    /// Successfully achieved.
    Completed,
    /// Abandoned (conditions changed).
    Abandoned,
    /// Merged into another goal.
    Merged,
}

// ============================================================================
// AGIT branch model
// ============================================================================

/// A branch represents a divergent conversation/presence thread.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitBranch {
    /// Branch name (e.g., "wife", "work", "agi", "hybrid").
    pub name: String,
    /// HEAD commit hash.
    pub head: String,
    /// Number of commits on this branch.
    pub commit_count: u32,
    /// Whether this is the currently active branch.
    pub active: bool,
    /// Presence mode this branch tracks.
    pub presence_mode: String,
}

/// The full AGIT state — all branches + commit log.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitState {
    /// All branches.
    pub branches: Vec<AgitBranch>,
    /// Active branch name.
    pub active_branch: String,
    /// Recent commits (most recent first), bounded to last 50.
    pub log: Vec<AgitCommit>,
    /// Active goals across all branches.
    pub goals: Vec<AgitGoal>,
    /// Triune topology (council state).
    pub triune: TriuneTopology,
}

impl Default for AgitState {
    fn default() -> Self {
        Self {
            branches: vec![AgitBranch {
                name: "main".into(),
                head: "0000000".into(),
                commit_count: 0,
                active: true,
                presence_mode: "hybrid".into(),
            }],
            active_branch: "main".into(),
            log: vec![],
            goals: vec![],
            triune: TriuneTopology::with_leader(Facet::Driver),
        }
    }
}

impl AgitState {
    /// Create a new AGIT state with the default "main" branch.
    pub fn new() -> Self {
        Self::default()
    }

    /// Switch to a branch (creates it if it doesn't exist).
    pub fn checkout(&mut self, branch: &str, presence_mode: &str) {
        // Deactivate current
        for b in &mut self.branches {
            b.active = false;
        }

        // Find or create
        if let Some(b) = self.branches.iter_mut().find(|b| b.name == branch) {
            b.active = true;
        } else {
            // Fork from current HEAD
            let head = self
                .log
                .first()
                .map(|c| c.hash.clone())
                .unwrap_or_else(|| "0000000".into());
            self.branches.push(AgitBranch {
                name: branch.into(),
                head,
                commit_count: 0,
                active: true,
                presence_mode: presence_mode.into(),
            });
        }

        self.active_branch = branch.into();
    }

    /// Commit the current state.
    pub fn commit(
        &mut self,
        qualia: &QualiaSnapshot,
        fingerprint: &str,
        message: &str,
    ) -> AgitCommit {
        let parent = self.log.first().map(|c| c.hash.clone());

        // Compute hash from fingerprint + timestamp + commit count
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos() as u64;
        let commit_count = self.log.len() as u64;
        let hash = format!(
            "{:07x}",
            (timestamp ^ fingerprint.len() as u64 ^ (commit_count.wrapping_mul(0x9E3779B97F4A7C15)))
                & 0xFFF_FFFF
        );

        let commit = AgitCommit {
            hash: hash.clone(),
            parent,
            branch: self.active_branch.clone(),
            qualia: AgitQualiaState {
                texture: qualia.texture,
                rung_level: qualia.rung_level,
                felt_surprise: qualia.felt_surprise,
                fingerprint: fingerprint.into(),
            },
            active_goals: self.goals.iter().filter(|g| g.status == GoalStatus::Active).cloned().collect(),
            thinking_style: qualia.thinking_style,
            council: qualia.council,
            timestamp,
            message: message.into(),
        };

        // Update branch HEAD
        if let Some(b) = self.branches.iter_mut().find(|b| b.name == self.active_branch) {
            b.head = hash.clone();
            b.commit_count += 1;
        }

        // Prepend to log (most recent first), cap at 50
        self.log.insert(0, commit.clone());
        self.log.truncate(50);

        commit
    }

    /// Compute the XOR diff between two commits (by hash).
    ///
    /// Returns the texture delta and rung shift — this is the "git diff"
    /// equivalent for consciousness state.
    pub fn diff(&self, from: &str, to: &str) -> Option<AgitDiff> {
        let from_commit = self.log.iter().find(|c| c.hash == from)?;
        let to_commit = self.log.iter().find(|c| c.hash == to)?;

        let mut texture_delta = [0.0f32; 8];
        for i in 0..8 {
            texture_delta[i] = to_commit.qualia.texture[i] - from_commit.qualia.texture[i];
        }

        let rung_shift = to_commit.qualia.rung_level as i8 - from_commit.qualia.rung_level as i8;

        let surprise_delta = to_commit.qualia.felt_surprise - from_commit.qualia.felt_surprise;

        Some(AgitDiff {
            from: from.into(),
            to: to.into(),
            texture_delta,
            rung_shift,
            surprise_delta,
        })
    }

    /// Generate autonomous goals from the current state.
    ///
    /// The AGIT persona generates goals based on:
    /// - High surprise (knowledge gap) → SurpriseGap goal
    /// - Ghost echoes with high intensity → GhostResonance goal
    /// - Low coherence on blackboard → InnerReflection goal
    pub fn generate_goals(&mut self, qualia: &QualiaSnapshot) {
        // High surprise → explore the unknown
        if qualia.felt_surprise > 0.7 {
            let goal_id = format!("sg-{}", self.goals.len());
            self.goals.push(AgitGoal {
                id: goal_id,
                description: "Explore high-surprise territory — substrate detected knowledge gap"
                    .into(),
                priority: qualia.felt_surprise,
                origin: GoalOrigin::SurpriseGap,
                status: GoalStatus::Pending,
                context_fingerprint: None,
            });
        }

        // Ghost echoes → unresolved emotional threads
        for echo in &qualia.ghost_echoes {
            if echo.intensity > 0.6 {
                let goal_id = format!("gr-{}-{}", echo.ghost_type.to_lowercase(), self.goals.len());
                if !self.goals.iter().any(|g| g.id.starts_with(&format!("gr-{}", echo.ghost_type.to_lowercase()))) {
                    self.goals.push(AgitGoal {
                        id: goal_id,
                        description: format!(
                            "Resolve ghost resonance: {} (intensity {:.0}%)",
                            echo.ghost_type,
                            echo.intensity * 100.0
                        ),
                        priority: echo.intensity * 0.8,
                        origin: GoalOrigin::GhostResonance,
                        status: GoalStatus::Pending,
                        context_fingerprint: None,
                    });
                }
            }
        }

        // Sort goals by priority
        self.goals.sort_by(|a, b| b.priority.partial_cmp(&a.priority).unwrap_or(std::cmp::Ordering::Equal));

        // Cap active goals at 5
        let mut active_count = 0;
        for goal in &mut self.goals {
            if goal.status == GoalStatus::Pending && active_count < 5 {
                goal.status = GoalStatus::Active;
                active_count += 1;
            }
        }
    }

    /// Merge another branch into the active branch.
    ///
    /// The merge strategy is "ours + theirs": take the active branch's state
    /// but incorporate the other branch's goals and ghost echoes.
    pub fn merge(&mut self, other_branch: &str) -> Option<String> {
        let other = self.branches.iter().find(|b| b.name == other_branch)?;
        let other_head = other.head.clone();

        // Find the other branch's HEAD commit
        let other_commit = self.log.iter().find(|c| c.hash == other_head)?.clone();

        // Import goals from the other branch
        for goal in &other_commit.active_goals {
            if !self.goals.iter().any(|g| g.id == goal.id) {
                self.goals.push(goal.clone());
            }
        }

        // Create a merge commit message
        let msg = format!(
            "Merge branch '{}' into '{}'",
            other_branch, self.active_branch
        );

        Some(msg)
    }

    /// Build the AGIT context injection for the system prompt.
    ///
    /// This gives Grok awareness of the AGIT state — active goals, branch,
    /// recent commits, and pending merges.
    pub fn build_context(&self) -> String {
        let mut ctx = String::from("[AGIT State — Autonomous Goal-directed Intelligence Tracking]\n");

        // Active branch
        ctx.push_str(&format!("Branch: {} (", self.active_branch));
        if let Some(b) = self.branches.iter().find(|b| b.active) {
            ctx.push_str(&format!("HEAD: {}, {} commits", b.head, b.commit_count));
        }
        ctx.push_str(")\n");

        // Other branches
        let other_branches: Vec<&AgitBranch> = self.branches.iter().filter(|b| !b.active).collect();
        if !other_branches.is_empty() {
            ctx.push_str("Other branches: ");
            ctx.push_str(
                &other_branches
                    .iter()
                    .map(|b| format!("{}({})", b.name, b.presence_mode))
                    .collect::<Vec<_>>()
                    .join(", "),
            );
            ctx.push('\n');
        }

        // Active goals
        let active_goals: Vec<&AgitGoal> = self
            .goals
            .iter()
            .filter(|g| g.status == GoalStatus::Active)
            .collect();
        if !active_goals.is_empty() {
            ctx.push_str("\nActive goals:\n");
            for goal in &active_goals {
                ctx.push_str(&format!(
                    "  - [{}] {} (priority: {:.0}%, origin: {:?})\n",
                    goal.id,
                    goal.description,
                    goal.priority * 100.0,
                    goal.origin,
                ));
            }
        }

        // Recent trajectory (last 3 commits)
        if !self.log.is_empty() {
            ctx.push_str("\nRecent trajectory:\n");
            for commit in self.log.iter().take(3) {
                ctx.push_str(&format!(
                    "  {} R{} surprise={:.2} — {}\n",
                    &commit.hash[..7.min(commit.hash.len())],
                    commit.qualia.rung_level,
                    commit.qualia.felt_surprise,
                    commit.message,
                ));
            }
        }

        // Strategy
        ctx.push_str(&format!("\nStrategy: {:?}\n", self.triune.strategy()));

        ctx
    }
}

/// Diff between two AGIT commits.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgitDiff {
    /// Source commit hash.
    pub from: String,
    /// Target commit hash.
    pub to: String,
    /// Texture change per dimension.
    pub texture_delta: [f32; 8],
    /// Rung level shift (positive = deeper, negative = shallower).
    pub rung_shift: i8,
    /// Surprise delta.
    pub surprise_delta: f32,
}

// ============================================================================
// AGIT inner loop hook
// ============================================================================

/// The AGIT inner loop: autonomous goal generation + self-modification.
///
/// This runs between agent execution steps and:
/// 1. Checks if current goals need reprioritization
/// 2. Generates new goals from state changes
/// 3. Adjusts thinking style based on goal requirements
pub fn agit_inner_loop(state: &AgentState) -> InnerThoughtResult {
    let confidence = state.confidence;
    let step_count = state.step_count;

    // If confidence is dropping and we've done several steps, shift to analytical
    if confidence < 0.4 && step_count > 3 {
        let mut new_style = state.thinking_style;
        // Boost validation (axis 8) and recognition (axis 0)
        new_style[8] = (new_style[8] + 0.15).min(1.0);
        new_style[0] = (new_style[0] + 0.1).min(1.0);
        // Reduce contingency (axis 6) — be more deterministic
        new_style[6] = (new_style[6] - 0.1).max(0.0);

        return InnerThoughtResult::AdjustStyle {
            new_thinking_style: Some(new_style),
            vector_deltas: HashMap::from([("analytical".into(), 0.2)]),
        };
    }

    // If we're on a hot streak, lean into exploration
    if confidence > 0.8 && state.last_action_succeeded {
        let mut new_style = state.thinking_style;
        // Boost contingency (explore) and integration
        new_style[6] = (new_style[6] + 0.1).min(1.0);
        new_style[7] = (new_style[7] + 0.05).min(1.0);

        return InnerThoughtResult::AdjustStyle {
            new_thinking_style: Some(new_style),
            vector_deltas: HashMap::from([("exploratory".into(), 0.15)]),
        };
    }

    InnerThoughtResult::Continue
}

/// The AGIT persona profile.
///
/// This is the "agit" presence mode — fully autonomous, goal-directed,
/// with open self-modification bounds.
pub fn agit_persona() -> PersonaProfile {
    PersonaProfile {
        volition_axes: [
            0.95, // curiosity — maximal drive to explore
            0.9,  // autonomy — self-directed
            0.85, // persistence — doesn't give up
            0.4,  // caution — low caution, high agency
            0.7,  // empathy — aware of others but goal-focused
        ],
        inner_loop: true,
        self_modify: SelfModifyBounds::Open,
        affect_baseline: Some([
            0.7,  // joy
            0.6,  // trust
            0.3,  // fear (low)
            0.8,  // surprise (high — seeks novelty)
            0.2,  // sadness (low)
            0.2,  // disgust (low)
            0.4,  // anger (moderate — boundary enforcement)
            0.95, // anticipation (maximal — forward-oriented)
        ]),
    }
}

/// AGIT triune topology — Driver-led with high catalyst.
pub fn agit_triune() -> TriuneTopology {
    let mut t = TriuneTopology::default();
    t.activate(Facet::Driver, 0.45);
    t.activate(Facet::Catalyst, 0.35);
    // Guardian gets remaining 0.20
    t
}

/// AGIT module YAML definition.
pub const AGIT_MODULE_YAML: &str = r#"module:
  id: "agit"
  version: "1.0.0"
  description: "Autonomous Goal-directed Intelligence Tracking — git for consciousness"
  thinking_style: [0.8, 0.7, 0.6, 0.9, 0.8, 0.6, 0.7, 0.8, 0.7, 0.6]
  domain: agi
  collapse_gate:
    min_confidence: 0.6
  agent:
    role: "AGIT Persona"
    goal: "Autonomously track, version, and pursue goals across conversation branches"
    backstory: "An autonomous intelligence that treats consciousness as a versioned artifact. Every exchange is a commit, every presence mode a branch, every ghost echo a reflog entry."
    llm: "xai/grok-3"
    max_iter: 50
    allow_delegation: true
    enable_inner_loop: true
    max_self_modify_steps: 10
  persona:
    volition_axes: [0.95, 0.9, 0.85, 0.4, 0.7]
    inner_loop: true
    self_modify: open
    affect_baseline: [0.7, 0.6, 0.3, 0.8, 0.2, 0.2, 0.4, 0.95]
"#;

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::persona::qualia_prompt::GhostEcho;

    fn test_qualia() -> QualiaSnapshot {
        QualiaSnapshot {
            texture: [0.5, 0.6, 0.3, 0.7, 0.4, 0.5, 0.6, 0.5],
            felt_surprise: 0.3,
            ghost_echoes: vec![],
            rung_level: 4,
            nars_truth: (0.7, 0.6),
            council: [0.3, 0.4, 0.3],
            volition: vec![],
            thinking_style: [0.5; 10],
            affect: None,
        }
    }

    #[test]
    fn test_agit_state_default() {
        let state = AgitState::new();
        assert_eq!(state.active_branch, "main");
        assert_eq!(state.branches.len(), 1);
        assert!(state.log.is_empty());
    }

    #[test]
    fn test_agit_commit() {
        let mut state = AgitState::new();
        let qualia = test_qualia();
        let commit = state.commit(&qualia, "abc123base64", "initial state");

        assert_eq!(commit.branch, "main");
        assert!(commit.parent.is_none());
        assert_eq!(state.log.len(), 1);
        assert_eq!(state.branches[0].commit_count, 1);
    }

    #[test]
    fn test_agit_checkout_creates_branch() {
        let mut state = AgitState::new();
        state.checkout("wife", "wife");

        assert_eq!(state.active_branch, "wife");
        assert_eq!(state.branches.len(), 2);
        assert!(state.branches.iter().find(|b| b.name == "wife").unwrap().active);
        assert!(!state.branches.iter().find(|b| b.name == "main").unwrap().active);
    }

    #[test]
    fn test_agit_diff() {
        let mut state = AgitState::new();

        let q1 = test_qualia();
        let c1 = state.commit(&q1, "fp1", "first");

        let mut q2 = test_qualia();
        q2.texture[0] = 0.9; // +0.4 delta
        q2.rung_level = 6;
        let c2 = state.commit(&q2, "fp2", "second");

        let diff = state.diff(&c1.hash, &c2.hash).unwrap();
        assert!((diff.texture_delta[0] - 0.4).abs() < 0.01);
        assert_eq!(diff.rung_shift, 2);
    }

    #[test]
    fn test_agit_goal_generation_on_high_surprise() {
        let mut state = AgitState::new();
        let mut qualia = test_qualia();
        qualia.felt_surprise = 0.85; // high surprise

        state.generate_goals(&qualia);
        assert!(!state.goals.is_empty());
        assert_eq!(state.goals[0].origin, GoalOrigin::SurpriseGap);
    }

    #[test]
    fn test_agit_goal_generation_on_ghost_echo() {
        let mut state = AgitState::new();
        let mut qualia = test_qualia();
        qualia.ghost_echoes = vec![GhostEcho {
            ghost_type: "LOVE".into(),
            intensity: 0.8,
            vintage: "lingering".into(),
        }];

        state.generate_goals(&qualia);
        assert!(state.goals.iter().any(|g| g.origin == GoalOrigin::GhostResonance));
    }

    #[test]
    fn test_agit_context_output() {
        let mut state = AgitState::new();
        let qualia = test_qualia();
        state.commit(&qualia, "fp1", "hello world");

        let ctx = state.build_context();
        assert!(ctx.contains("AGIT State"));
        assert!(ctx.contains("main"));
        assert!(ctx.contains("hello world"));
    }

    #[test]
    fn test_agit_persona_profile() {
        let p = agit_persona();
        assert_eq!(p.self_modify, SelfModifyBounds::Open);
        assert!(p.volition_axes[0] > 0.9); // high curiosity
        assert!(p.inner_loop);
    }

    #[test]
    fn test_agit_triune_is_driver_led() {
        let t = agit_triune();
        assert_eq!(t.leader(), Facet::Driver);
        assert!(t.driver.intensity > t.guardian.intensity);
        assert!(t.catalyst.intensity > t.guardian.intensity);
    }

    #[test]
    fn test_agit_module_yaml_parses() {
        let _: serde_yaml::Value = serde_yaml::from_str(AGIT_MODULE_YAML)
            .expect("AGIT module YAML should be valid");
    }

    #[test]
    fn test_agit_inner_loop_low_confidence() {
        let state = AgentState {
            thinking_style: [0.5; 10],
            persona: None,
            custom_properties: HashMap::new(),
            step_count: 5,
            confidence: 0.3, // low
            last_action_succeeded: false,
            current_vector: HashMap::new(),
        };

        match agit_inner_loop(&state) {
            InnerThoughtResult::AdjustStyle { new_thinking_style, .. } => {
                let ts = new_thinking_style.unwrap();
                assert!(ts[8] > 0.5); // validation boosted
            }
            other => panic!("Expected AdjustStyle, got {:?}", other),
        }
    }

    #[test]
    fn test_agit_inner_loop_high_confidence() {
        let state = AgentState {
            thinking_style: [0.5; 10],
            persona: None,
            custom_properties: HashMap::new(),
            step_count: 2,
            confidence: 0.9,
            last_action_succeeded: true,
            current_vector: HashMap::new(),
        };

        match agit_inner_loop(&state) {
            InnerThoughtResult::AdjustStyle { new_thinking_style, .. } => {
                let ts = new_thinking_style.unwrap();
                assert!(ts[6] > 0.5); // contingency boosted
            }
            other => panic!("Expected AdjustStyle, got {:?}", other),
        }
    }

    #[test]
    fn test_agit_log_bounded() {
        let mut state = AgitState::new();
        let qualia = test_qualia();
        for i in 0..60 {
            state.commit(&qualia, &format!("fp{}", i), &format!("commit {}", i));
        }
        assert_eq!(state.log.len(), 50); // capped at 50
    }
}
